# データベース概要

この項ではデータベースの概要およびSQLの概要、MySQLの概要を学びます。

## データベースとは何か

特定の目的のためのデータを管理して、検索、更新を容易にしたものです。

ただし、Webサービス(に限らないですが、)においてはデータベースには以下のような要件が求められてます。

- 並列性
    - 多数のクライアントが同時にデータにアクセス出来ること
- 高速性
    - 大量のデータの中から適切なデータを高速に返せること
- 耐障碍性
    - 障碍が起きた時に迅速に復旧が可能なこと
- 整合性
    - データが矛盾無く参照/更新されること

アプリケーションの性質によっては全ての要件を満たす必要は無いですが、
MySQLはこれらの要件を満たしてるので多くのWebサービスで使われてます。

## データモデル

データの論理的/物理的な表現方法のことです。

扱うデータの性質によって、向き不向きがあります。

以下のようなデータモデルがあります。

- 階層型
- ネットワーク型
- リレーショナル
- オブジェクト
- カード型
- キーバリュー型

今回扱うMySQLはリレーショナルモデルを扱うデータベースです。

## リレーショナルモデル

リレーショナルモデルは現在のシステム開発に於いて広く使われているデータモデルです。
これも話し出すとだいぶ深くなるのでざっくりと。[理論から学ぶデータベース実践入門 ~リレーショナルモデルによる効率的なSQL](http://www.amazon.co.jp/dp/4774171972/)に詳しいです。


### リレーショナルモデルの要素

- リレーション(関係)
    - 1つの見出しと0以上の同じドメインのタプルから構成される、**順序づけされてない**集合からなるデータ構造
- タブル(組)
    - 1つ以上のアトリビュート属性の集合からなるデータ構造
- アトリビュート(属性)
    - アトリビュート名とドメインからなるペア
- ドメイン(定義域)
    - データ型と考えて良い
    - あるデータ要素が取り得る一意な値からなる有限集合


社員リレーションの例で考えてみる

    アトリビュート(順不同)
        |
        V
    +---------------+-------------+----------------+
    | 名前:文字列型 | 年齢:整数型 | 部署:文字列型  |   <= 見出し
    +---------------+-------------+----------------+
    | 山田太郎      | 19          | 総務部         |   <= タプル(順不同)
    +---------------+-------------+----------------+
    | 山田花子      | 22          | 開発部         |
    +---------------+-------------+----------------+

便宜上、表で書いてますが、アトリビュートにもタプルにも順序は無いです。

### 正規化

話すとだいぶ長くなるので、概要だけ。

正規化とはデータの冗長制を排除して、一貫性と効率性を保持するための作業です。
正規化には段階があり、第一正規形~第五正規形がよく用いられます。
nNFという表記が用いられる。第一正規形なら1NFと言った具合。

実務では(*意識せずに*)3NFまでの正規化が行われることが多いです。
基本的に、特別な理由が無い限りパフォーマンスに著しい支障があるなど特別な事情が無い限りは、正規化を崩すことはしないです。


### リレーショナルモデルの実装

リレーショナルデータベースとしては以下のものがあります。

- [MySQL](http://www.mysql.com/) / [MariaDB](https://mariadb.org/) / [Percona Server](http://www.percona.com/software/percona-server)
- [PostgreSQL](http://www.postgresql.org/)
- [MycroSoft SQL Serevr](http://www.microsoft.com/ja-jp/sqlserver)
- [Oracle Database](http://www.oracle.com/jp/database/overview/)
- [SQLite](https://www.sqlite.org/)
- [H2 Database](http://www.oracle.com/jp/database/overview/)


## SQL(えす･きゅー･える/しーくぇる)

主にリレーショナルデータベースにおいてデータの操作や定義を行うための言語。宣言型プログラミング言語に分類されます。
リレーショナルモデルにある程度基づいた演算体系です。

SQLは大きく分けて3つ区分があります。

- データ定義言語(DDL Data Difinition Language)
    - CREATE
    - DROP
    - ALTER
- データ操作言語(DML Data Manipulation Language)
    - INSERT
    - UPDATE
    - DELETE
    - SELECT
- データ制御言語(DCL Data Control Language)
    - GRANT
    - REVOKE
    - SET TRANSACTION
    - BEGIN
    - COMMIT
    - ROLLBACK
    - SAVEPOINT
    - LOCK

### SQLとリレーショナルモデルの差異

用語の差異

| リレーショナルモデル | SQL             |
|:---------------------|:----------------|
| リレーション         | table(テーブル) |
| タブル               | row(行)         |
| アトリビュート       | column(列)      |
| ドメイン             | type(型)        |


- rowの順番は主キーに順序づけされてる
- columnの順番はtable定義時に順序づけされている
- NULLの存在
- インデックスの存在


## MySQL(まい･えす･きゅー･える)

MySQLはリレーショナルモデルで表現されており、SQL言語によって操作できるデータベースです。
オープンソースであり、GNU GPLと商用ライセンスを採用しています。

開発元はMySQL AB => Sun Microsystems => Oracleと変遷しました。
MySQLのフォークとしてMariaDBというデータベースシステムも存在します。

現在のところWebサービスで広く使われているデータベースシステムです。

### ストレージエンジン

MySQLではストレージエンジンをテーブル毎に用途に合わせて差し替えることが出来ます。
特別な用途がなければ基本的にはInnoDBを使います。

`SHOW ENGIES` で利用できるストレージエンジンが確認できます。

```
> SHOW ENGINES;
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
```

### InnoDBとMyISAM

広く使われているストレージエンジンはInnoDBとMyISAMです。
現在ではInnoDBが基本的に使用されています。
特殊な用途や古いシステム以外ではMyISAMは使われないです。

- InnoDB
    - MySQL 5.5からデフォルトのストレージエンジン
    - トランザクション可能
    - 読み込み処理でロックを行わない
    - 行ロックが可能
    - 外部キーをサポート
    - 主キーによるルックアップが高速
- MyISAM
    - MySQL 5.1までのデフォルトのストレージエンジン
    - テーブル全体をロックする
    - トランザクション処理が不可能

## トランザクションとロック

Webシステムではユーザが同時に同じデータに対して、更新を行う可能性があります。
そういった場合にデータを適切に更新するための仕組みがトランザクションとロックです。

### トランザクション

トランザクション処理も話すと1日では終わらないので、概要だけ。

データの一貫性を保つために複数の処理を1つの単位として不可分に行うことをトランザクションと言います。


銀行口座の振り込みの例で考えます。

`USER_A`が`USER_B`の口座に100,000振り込む処理は以下のようになります。

1. `USER_A`の口座を100,000減らす
2. `USER_B`の口座を100,000増やす


`銀行口座テーブル`

    +---------+------------+
    | user    | balance    |
    +---------+------------+
    | USER_A  | 100000     |
    | USER_B  | 300000     |
    +---------+------------+

通常であれば、問題ないですが、1.と2.の間で何らかのエラーが起きて、2.が実行されなかったとしたら、
`USER_A`の100,000は無に消えたことになり、データの不整合が起きることになります。

こういったことを防ぐためのトランザクションを行います。

1. トランザクションを開始する
2. `USER_A`の口座を100,000減らす
3. `USER_B`の口座を100,000増やす
4. トランザクションをコミットする

トランザクションが`コミット`されるまで、当該トランザクションで更新されたデータは確定しません。
コミット前に何らかのエラーが起きた場合、`ロールバック`して当該トランザクションでの更新処理は無かったことになります。
トランザクション内の処理は処理されたか、されてないかのいずれの状態になり、途中まで実行されたという中途半端な状態はなくなります。

### ロック

特定の目的のために、他のセッションからの更新処理を出来ないようにデータをロックすることができます。
InnoDBでは行単位のロックが可能です。(MyISAMではテーブルロックのみで行ロック不可能)

RPGゲームを例に以下の場合を考えます。以下の仕様だと考えてください。

- `USER_A`は毒の状態です。
- 毒の状態だと一定時間毎に10のダメージを受けます。

現在のステータスは以下のようになっています。

    +---------+------------+---------------+--------+
    | user    | hit_point  | max_hit_point | status |
    +---------+------------+---------------+--------+
    | USER_A  | 10         | 300           | poison |
    | USER_B  | 300        | 300           | normal |
    +---------+------------+---------------+--------+

このときほぼ同時に以下の順番で処理されることを想定します。

1. `USER_A`が毒の状態を回復
2. 毒状態の判定、毒であれば10ダメージ受ける
3. `USER_B`が`USER_A`を100回復


通常であれば、この3つの処理が終わった後の`USER_A`の`hit_point`は110となります。
しかしながら、1.と2.の処理がほぼ同時に実行されて、
2.を処理するにあたって参照された`USER_A`の`status`が1.の実行前であれば、
毒状態であると判定されて、2.の処理で`USER_A`は死亡したことになってしまいます。

こういった不整合を避けるために、ロックの仕組みがあります。
1.の処理の前に`USER_A`のデータの排他ロックを取得し、処理が終わったら解除します。(通常はトランザクションがコミット/ロールバックしたときに解除されます。)
同様に2.の処理の前に`USER_A`のデータの排他ロックを取得します。ただし、1.の処理が終わってないので、それが終わる(ロックが解除される)まで待ちます。1.の処理が終わった後には`status`が`normal`になってるので、`USER_A`が毒のダメージを受けません。
ロックを適切にかけることにより、不整合を防ぐことができました。


### デッドロック

2つ以上の処理が互いにそれぞれの処理の終了待ちをして、互いに処理が止まってしまうことをデッドロックと言います。
InnoDBにおいてはデットロックを検知すると、更新が少ない方のトランザクションがロールバックされます。

今回も銀行口座の振り込みの例で考えてみます。

- [deadlock.sql](../sql/deadlock.sql)

1. `USER_A`が`USER_B`の口座に10,000振り込む
    1. `USER_A`の口座を10,000減らす
    2. `USER_B`の口座を10,000増やす
2. `USER_B`が`USER_A`の口座に20,000振り込む
    1. `USER_B`の口座を20,000減らす
    2. `USER_A`の口座を20,000増やす

この状態で下記の順番で処理が実行されるとデッドロックが生じます。


    `USER_A`の振り込み処理                   `USER_B`の振り込み処理
    1-1.`USER_A`の口座を10,000減らす
            |                                2-1.`USER_B`の口座を20,000減らす
            V                                       |
    1-2.`USER_B`の口座を10,000増やす                |
    (ロック開放待ち)                                |
                                             2-2.`USER_A`の口座を20,000増やす
                                             (ロック開放待ち)
                                                    |
                                                    V
                                             デッドロック!!!

`銀行口座テーブル`

    +---------+------------+
    | user    | balance    |
    +---------+------------+
    | USER_A  | 100000     |
    | USER_B  | 300000     |
    +---------+------------+


この例ではデッドロック防ぐのは難しいですが、複数テーブルロックする際は、ロックするテーブルの順番や、
ロックする行数自体を減らしてあげることで、デッドロックを起こしにくくすることができます。


## インデックス

インデックスとは大量のデータの中で目的のデータに高速にアクセスするためのデータ構造です。

通常インデックスが何も無い場合、全てのデータにアクセスして目的のデータを検索しなければなりません。
インデックスを特定のカラムに付けることによって特定カラムにおける検索を高速にすることができます。


実装としては以下のものがあります。

- B+Treeインデックス
- ハッシュインデックス
- ビットマップインデックス

# InnoDBのインデックス

InnoDBのデフォルトのインデックスはB+Treeです。
平衡分木データ構造を取り、プライマリーキー(主キー)のリーフノードに実データがクラスタで格納されています。
セカンダリインデックスのリーフノードにはセカンダリインデックスの値とプライマリーキーの値が格納されています。

このデータ構造によりInnoDBは以下の特長を持ちます

- プライマリーキーでの検索が高速
- プライマリーキーの範囲検索が高速
- セカンダリーキーで検索した場合でも、選択カラムがプライマリーキーの値のみであれば、高速
    - セカンダリーキーだけのルックアップでプライマリキーの値が取得出来るため
    - CoveringIndex
- プライマリーキーの変更コストが高い
- プライマリーキー長が長いと必然的にデータサイズも大きくなる
    - 全てのセカンダリーキーにプライマリーキーが格納されるため


```
    プライマリーインデックス図式

    プライマリーキー: user_id
    セカンダリーキー: department_id

                       +---+
                       |   |
                       +---+
                         |
               +---------+----------+
               |         |          |
             +---+     +---+      +---+
             |   |     |   |      |   |
             +---+     +---+      +---+
               |         |          |
        +------+      +------+      +------+
        |      |      |      |      |      |
      +---+  +---+  +---+  +---+  +---+  +---+
      |   |  |   |  |   |  |   |  |   |  |   |
      +---+  +---+  +---+  +---+  +---+  +---+
               |
         +-----------------------------------+
         | user_id=12, department_id=1, .... |
         | user_id=13, department_id=1, .... |
         | ....                              |
         | ....                              |
         | user_id=20, department_id=3, .....|
         +-----------------------------------+
```

```
    セカンダリーインデックス図式

                       +---+
                       |   |
                       +---+
                         |
               +---------+----------+
               |         |          |
             +---+     +---+      +---+
             |   |     |   |      |   |
             +---+     +---+      +---+
               |         |          |
        +------+      +------+      +-------+
        |      |      |      |      |       |
      +---+  +---+  +---+  +---+  +---+  +---+
      |   |  |   |  |   |  |   |  |   |  |   |
      +---+  +---+  +---+  +---+  +---+  +---+
               |
         +-----------------------------------+
         + department_id=2, user_id=1        |
         + department_id=2, user_id=4        |
         + .....                             |
         + department_id=2, user_id=14       |
         +-----------------------------------+
```


## 発展

- 各データモデルが有用なユースケースは何だろうか?
- 各データモデルの実装に何があるのか?
- 第五正規形までそれそれどんなものであるか?
- MySQL以外のデータベース製品の特長とユースケースはなんだろうか?
- InnoDBとMyISAMの他にどんなストレージエンジンがあるのか?そしてどういう特徴があるのか?
- ロックには排他ロック/共有ロックがあるがどのようなものだろうか?
- トランザクションシステムが満たすべき要件として`ACID要件`があるがそれはどんなものか?
- 複数トランザクションが同時に行われたときの挙動を定めた`トランザクション分離レベル`があるが、それはどのようなものか?MySQLのデフォルトはどうなっているか?


## リソース

- Web
    - [MySQL Casual Advent Calendar 2011](http://mysql-casual.org/2011/11/mysql-casual-advent-calendar-2011.html)
    - [MySQL Casual Advent Calendar 2013](http://www.zusaar.com/event/1847003)
    - [MySQL Casual Advent Calendar 2014](http://qiita.com/advent-calendar/2014/mysql-casual)
    - [リレーショナル・データベースの世界](http://www.geocities.jp/mickindex/database/idx_database.html)
    - [MySQLのロックについて](http://d.hatena.ne.jp/sh2/20140914)
    - [InnoDBのロックの範囲とネクストキーロックの話](http://blog.kamipo.net/entry/2013/12/03/235900)
    - [知って得するInnoDBセカンダリインデックス活用術！](http://nippondanji.blogspot.jp/2010/10/innodb.html)

- 書籍
    - [理論から学ぶデータベース実践入門 ~リレーショナルモデルによる効率的なSQL](http://www.amazon.co.jp/dp/4774171973/)
    - [データベース実践講義 ―エンジニアのためのリレーショナル理論](http://www.amazon.co.jp/dp/4873112753/)
